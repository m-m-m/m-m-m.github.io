<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_91) on Sat Aug 06 16:03:08 CEST 2016 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>net.sf.mmm.service.api (JavaDocs for mmm-all dev-SNAPSHOT)</title>
<meta name="date" content="2016-08-06">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="net.sf.mmm.service.api (JavaDocs for mmm-all dev-SNAPSHOT)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../net/sf/mmm/search/view/base/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../net/sf/mmm/service/api/client/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?net/sf/mmm/service/api/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;net.sf.mmm.service.api</h1>
<div class="docSummary">
<div class="block">Contains the API for simple remote invocations to communicate between client and server.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../net/sf/mmm/service/api/CsrfToken.html" title="interface in net.sf.mmm.service.api">CsrfToken</a></td>
<td class="colLast">
<div class="block">This is the interface for a security token to prevent <em>cross site request forgery</em> (CSRF) and
 potentially other attacks.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../../net/sf/mmm/service/api/RemoteInvocationCall.html" title="interface in net.sf.mmm.service.api">RemoteInvocationCall</a></td>
<td class="colLast">
<div class="block">This is the marker interface for a single remote invocation.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../net/sf/mmm/service/api/DefaultCsrfToken.html" title="class in net.sf.mmm.service.api">DefaultCsrfToken</a></td>
<td class="colLast">
<div class="block">This is the default implementation of <a href="../../../../../net/sf/mmm/service/api/CsrfToken.html" title="interface in net.sf.mmm.service.api"><code>CsrfToken</code></a> it simply uses a <a href="../../../../../net/sf/mmm/service/api/DefaultCsrfToken.html#getValue--"><code>string value</code></a>
 as payload.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation">
<caption><span>Exception Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Exception</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../net/sf/mmm/service/api/RemoteInvocationCallFailedException.html" title="class in net.sf.mmm.service.api">RemoteInvocationCallFailedException</a></td>
<td class="colLast">
<div class="block">This exception is thrown if <a href="../../../../../net/sf/mmm/service/api/RemoteInvocationCall.html" title="interface in net.sf.mmm.service.api"><code>RemoteInvocationCall</code></a> has failed.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Annotation Types Summary table, listing annotation types, and an explanation">
<caption><span>Annotation Types Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Annotation Type</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../../net/sf/mmm/service/api/Login.html" title="annotation in net.sf.mmm.service.api">Login</a></td>
<td class="colLast">
<div class="block">This annotation for a <a href="../../../../../net/sf/mmm/service/api/RemoteInvocationCall.html" title="interface in net.sf.mmm.service.api"><code>RemoteInvocationCall</code></a> that provides the login
 operation.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package net.sf.mmm.service.api Description">Package net.sf.mmm.service.api Description</h2>
<div class="block">Contains the API for simple remote invocations to communicate between client and server.
 <a name="documentation"></a><h2>Service API</h2>
 This package and it sub-packages contain the API for remote invocations. The API (and implementations)
 provide a solution for simple but flexible and powerful remote invocations with focus on asynchronous processing on
 clients (e.g. web-clients using Google Web Toolkit, native JavaFx clients, etc.).
 <h3>The Problem</h3>
 In order to communicate between client and server there are various decisions to make and problems to solve:
 <ul>
 <li>Which communication protocol (e.g. REST, SOAP, etc.) and payload format (JSON, XML, BSON, hessian, etc.) should be used?
 This will heavily depend on your client. In case you have multiple clients you might need to implement all your
 services for different protocols.</li>
 <li>How to establish RPC-style (Remote Procedure Call) services with REST? How to map a business oriented processing
 operation to the REST scheme?</li>
 <li>How to map from your raw java service implementation to the payload format (marshalling and unmarshalling)?</li>
 <li>How to secure your services and protect against attacks such as CSRF? Regular REST is recommending submission of request parameters
 for read operations as part of the URL (path or get-parameter) leading to unencrypted transmission even with HTTPS.</li>
 <li>How to deal with exceptions? What about exposure of sensitive information via exceptions in production systems vs.
 development environment? How to ensure that internal exceptions can be de-serialized/un-marshaled on the client
 without dependency on the entire server code?</li>
 <li>How coarse- or fine-grained should service operations be designed? Too find-grained methods may cause larger overhead
 if multiple remote invocations (requests) have to be performed while too coarse-grained methods may prevent proper reusage.</li>
 <li>How to deal with cross-cutting concerns (that may even arise after a lot of services already have been implemented?</li>
 <li>How to deal with BLOBs? If we send them as <code>byte[]</code> you will end up with <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/OutOfMemoryError.html?is-external=true" title="class or interface in java.lang"><code>OutOfMemoryError</code></a>s
 on the server side as all concurrent BLOBs are loaded entirely in main memory. Instead a streaming API like
 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html?is-external=true" title="class or interface in java.io"><code>OutputStream</code></a> is required. But how should this work in a limited environment such as a GWT client?</li>
 </ul>
 For the different protocols and formats very technical solutions with a high flexibility exist.
 For example with JAX-RS we get code like this:
 <pre>
  @Path("/disposition/{dispositionId}/calculateTotal")
  @POST
  @Consumes("application/json")
  @Produces("application/json")
 public Amount calculateTotal( @PathParam("dispositionId") Long dispositionId, State dispositionState);
 </pre>
 You can see that there are a lot of considerations to care about. Also such approach is leading to redundancies if
 you have a large amount of services. Even worse, if your client is also written in Java the calling code is not
 directly related to the service operation. You have to manually ensure consistency so everything fits and works together.
 The latter is better with JAX-WS but SOAP is also causing a lot of problems and limitations.
 Also during development and maintenance it is hard to trace calls from the client to the server side implementation. <br>
 Solutions like JAX-RS and JAX-WS are cool and reasonable for external and interoperable services consumed by third-party
 vendors. However, for <em>internal services</em> (services dedicated to clients or other applications within the same
 application landscape typically under control of the same vendor) this is causing a lot of unnecessary effort and problems.
 Approaches like <code>spring-remoting</code> make your life a lot easier but still require you to configure every service
 on server- and client-side. Also it does not address all the questions we listed above.
 <h3>The Solution</h3>
 In case you want to realize <em>internal services</em> then <code>mmm-service</code> will make your life a lot easier.
 Technically it is based on existing solutions like <code>spring-remoting</code> (<code>HttpInvoker</code>, <code>hessian</code>),
 GWT-RPC, and others. Conceptional it defines a generic service via which all remote invocations are send and that
 has to be setup and configured only once. All services you define and implement are declared via
 <a href="../../../../../net/sf/mmm/util/component/api/Cdi.html" title="interface in net.sf.mmm.util.component.api"><code>CDI</code></a> and therefore automatically registered on the server side.
 This offers the following advantages:
 <ul>
 <li>Developers can simply concentrate on designing the service API and implementation. No extra effort is required to
 export the service and make it available. Only requirements are that you inherit a marker interface and that all the
 parameters and return types of your service API are <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>serializable</code></a> (If you want to support
 GWT-RPC this has the additional implication that fields are not declared as final and a non-arg constructor is is
 present - but does not have to be public).</li>
 <li>If server and client are both written in Java (what is the focused scenario) you can directly call the service
 API on the client. Everything remains traceable, type-safe, and participates in refactorings. The client only sees the
 API and should not know the implementation.</li>
 <li>Cross-cutting concerns like <a href="../../../../../net/sf/mmm/util/lang/api/concern/Security.html" title="interface in net.sf.mmm.util.lang.api.concern"><code>Security</code></a> are already build-in.
 If you have both secured and public service operations, you can configure how this is detected.
 By default JavaEE security annotations (JSR250) as well as <code>spring-security</code> are supported.</li>
 <li>On the client-side you can create a <a href="../../../../../net/sf/mmm/service/api/rpc/client/RemoteInvocationServiceQueue.html" title="interface in net.sf.mmm.service.api.rpc.client"><code>queue</code></a>
 that collects invocations and allows to bundle them into a single request to save overhead and boost your performance.
 The queuing of invocations can be configured independently of the code that actually triggers the remote invocations.</li>
 <li>Services that have been created can be made available via different protocols without changing the services.
 If you have multiple clients that require different protocols, you can configure your server to support these protocolls
 in parallel without extra effort. On the client side you simply choose the proper implementation of this
 <code>mmm-service</code> API for the desired protocol.</li>
 <li>Exceptions are properly <a href="../../../../../net/sf/mmm/util/exception/api/ExceptionUtil.html#convertForClient-java.lang.Throwable-"><code>"obfuscated"</code></a>
 according to the executing environment.</li>
 <li>Everything is designed in an open and flexible way. You can simply replace specific aspects. Also you can write
 implementations of this API for additional protocols and payload formats.</li>
 <li>Everything integrates seamless with <code>mmm-client</code> but can also be used standalone.</li>
 </ul>
 There are two supported styles available that you can choose from:
 <ul>
 <li><b>RPC style</b><br>
 Here you simply create an interface for your remote service that inherits from the marker interface
 <a href="../../../../../net/sf/mmm/service/api/rpc/RemoteInvocationService.html" title="interface in net.sf.mmm.service.api.rpc"><code>RemoteInvocationService</code></a>. Further, you create an server-side implementation for
 that interface. If you are using <a href="../../../../../net/sf/mmm/util/component/api/Cdi.html" title="interface in net.sf.mmm.util.component.api"><code>CDI</code></a> you only have to annotate the
 implementation with <code>Named</code> and that is all. <br>
 On the client side you will use <a href="../../../../../net/sf/mmm/service/api/rpc/client/RemoteInvocationServiceCaller.html" title="interface in net.sf.mmm.service.api.rpc.client"><code>RemoteInvocationServiceCaller</code></a> to
 <a href="../../../../../net/sf/mmm/service/api/rpc/client/RemoteInvocationServiceCaller.html#getServiceClient-java.lang.Class-java.lang.Class-net.sf.mmm.util.lang.api.function.Consumer-net.sf.mmm.util.lang.api.function.Consumer-"><code>get a stub of your service interface</code></a>
 while providing a callback that receives the result asynchronously and invoke a corresponding method on the stub.
 This way you can use your favorite IDE to directly step from the client-side service call to the server-side service
 implementation. For its simplicity and compliance with java service design this is the favorite approach.
 Here is a simple (undocumented and stupid) example that will show "Hi John" in a popup window:
 <pre>
 public interface HelloWorldService extends <a href="../../../../../net/sf/mmm/service/api/rpc/RemoteInvocationService.html" title="interface in net.sf.mmm.service.api.rpc"><code>RemoteInvocationService</code></a> {
   String sayHi(String name);
 }
  @<code>Named</code>
 public class HelloWorldService extends AbstractRemoteInvocationService implements HelloWorldService {
   public String sayHi(String name) {
     return "Hi " + name;
   }
 }
 public class ClientComponent {
   public void doSomething() {
     <a href="../../../../../net/sf/mmm/service/api/rpc/client/RemoteInvocationServiceCaller.html" title="interface in net.sf.mmm.service.api.rpc.client"><code>RemoteInvocationServiceCaller</code></a> caller = getCaller();
     HelloWorldService service = caller.<a href="../../../../../net/sf/mmm/service/api/rpc/client/AbstractRemoteInvocationServiceCaller.html#getServiceClient-java.lang.Class-java.lang.Class-net.sf.mmm.util.lang.api.function.Consumer-"><code>getServiceClient</code></a>(HelloWorldService.class, String.class, message -> showPopup(message));
     service.sayHi("John");
   }
 }
 </pre>
 </li>
 <li><b>Command style</b><br>
 This approach is implementing the <em>command pattern</em>. Here you create implementations of the marker interface
 <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommand.html" title="interface in net.sf.mmm.service.api.command"><code>RemoteInvocationCommand</code></a>s that represent a single service operation. This
 corresponds to a method of a <a href="../../../../../net/sf/mmm/service/api/rpc/RemoteInvocationService.html" title="interface in net.sf.mmm.service.api.rpc"><code>RemoteInvocationService</code></a> in RPC style and is a
 container for all method parameters. On the server-side you create a corresponding implementation of
 <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommandHandler.html" title="interface in net.sf.mmm.service.api.command"><code>RemoteInvocationCommandHandler</code></a>. If you are using <a href="../../../../../net/sf/mmm/util/component/api/Cdi.html" title="interface in net.sf.mmm.util.component.api"><code>CDI</code></a>
 you only have to annotate the implementation with <code>Named</code> and that is all. <br>
 On the client side you will use <a href="../../../../../net/sf/mmm/service/api/command/client/RemoteInvocationCommandCaller.html" title="interface in net.sf.mmm.service.api.command.client"><code>RemoteInvocationCommandCaller</code></a> to
 <a href="../../../../../net/sf/mmm/service/api/command/client/AbstractRemoteInvocationCommandCaller.html#callCommand-net.sf.mmm.service.api.command.RemoteInvocationCommand-net.sf.mmm.util.lang.api.function.Consumer-net.sf.mmm.util.lang.api.function.Consumer-"><code>call a command</code></a>. This is entirely type-safe due to the
 generic type &lt;RESULT&gt; of <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommand.html" title="interface in net.sf.mmm.service.api.command"><code>RemoteInvocationCommand</code></a>.
 As a further advantage it allows better optimization of serialization (e.g. in GWT the compiler needs to know which
 classes can be part of the invocation what can be any <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> in RPC while in command style only
 classes reachable from a <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommand.html" title="interface in net.sf.mmm.service.api.command"><code>RemoteInvocationCommand</code></a> are candidates). Finally it does
 not require code generation (for client stubs) in GWT environment where no reflection (dynamic proxies) is available.
 Here is a simple (undocumented and stupid) example that will show "Hi John" in a popup window:
 <pre>
 public class HelloWorldCommand implements <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommand.html" title="interface in net.sf.mmm.service.api.command"><code>RemoteInvocationCommand</code></a> &lt;String&gt; {
   private static final long serialVersionUID = 1L;
   private String name;
   public HelloWorldCommand(String name) {
     super();
     this.name = name;
   }
   public String getName() {
     return this.name;
   }
 }
  @<code>Named</code>
 public class HelloWorldCommandHandler implements <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommandHandler.html" title="interface in net.sf.mmm.service.api.command"><code>RemoteInvocationCommandHandler</code></a>
 &lt;String, HelloWorldCommand&gt; {
   public String <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommandHandler.html#handle-COMMAND-"><code>handle</code></a>(HelloWorldCommand command) {
     return "Hi" + command.getName();
   }
   public Class &lt;HelloWorldCommand&gt; <a href="../../../../../net/sf/mmm/service/api/command/RemoteInvocationCommandHandler.html#getCommandClass--"><code>RemoteInvocationCommandHandler.getCommandClass()</code></a> {
     return HelloWorldCommand.class;
   }
 }
 public class ClientComponent {
   public void doSomething() {
     <a href="../../../../../net/sf/mmm/service/api/command/client/RemoteInvocationCommandCaller.html" title="interface in net.sf.mmm.service.api.command.client"><code>RemoteInvocationCommandCaller</code></a> caller = getCaller();
     HelloWorldCommand command = new HelloWorldCommand("John");
     caller.<a href="../../../../../net/sf/mmm/service/api/command/client/AbstractRemoteInvocationCommandCaller.html#callCommand-net.sf.mmm.service.api.command.RemoteInvocationCommand-net.sf.mmm.util.lang.api.function.Consumer-"><code>callCommand</code></a>(command, message -> showPopup(message));
   }
 }
 </pre>
 </li>
 </ul></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../net/sf/mmm/search/view/base/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../../../net/sf/mmm/service/api/client/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?net/sf/mmm/service/api/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2001&#x2013;2016 <a href="http://m-m-m.sourceforge.net/team-list.html">mmm-Team</a>. All rights reserved.</small></p>
</body>
</html>
